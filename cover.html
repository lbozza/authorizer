
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>processor: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">authorizer/processor/handler_mock.go (100.0%)</option>
				
				<option value="file1">authorizer/processor/processor.go (92.3%)</option>
				
				<option value="file2">authorizer/usecase/authorizer/authorize.go (100.0%)</option>
				
				<option value="file3">authorizer/usecase/authorizer/manager.go (100.0%)</option>
				
				<option value="file4">authorizer/usecase/authorizer/manager_mock.go (16.7%)</option>
				
				<option value="file5">authorizer/usecase/rules/double_transaction.go (100.0%)</option>
				
				<option value="file6">authorizer/usecase/rules/high_frequency_small_interval.go (100.0%)</option>
				
				<option value="file7">authorizer/usecase/rules/rule.go (100.0%)</option>
				
				<option value="file8">authorizer/usecase/rules/rules.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: authorizer/processor (interfaces: Handler)

// Package processor is a generated GoMock package.
package processor

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockHandler is a mock of Handler interface.
type MockHandler struct {
        ctrl     *gomock.Controller
        recorder *MockHandlerMockRecorder
}

// MockHandlerMockRecorder is the mock recorder for MockHandler.
type MockHandlerMockRecorder struct {
        mock *MockHandler
}

// NewMockHandler creates a new mock instance.
func NewMockHandler(ctrl *gomock.Controller) *MockHandler <span class="cov8" title="1">{
        mock := &amp;MockHandler{ctrl: ctrl}
        mock.recorder = &amp;MockHandlerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHandler) EXPECT() *MockHandlerMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Handle mocks base method.
func (m *MockHandler) Handle(arg0 Input) (Output, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Handle", arg0)
        ret0, _ := ret[0].(Output)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Handle indicates an expected call of Handle.
func (mr *MockHandlerMockRecorder) Handle(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockHandler)(nil).Handle), arg0)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package processor

import (
        "authorizer/entity"
        "encoding/json"
        "fmt"
        "io"
)

type Input struct {
        Account     *entity.Account     `json:"account"`
        Transaction *entity.Transaction `json:"transaction"`
}

type Output struct {
        Account    *entity.Account `json:"account"`
        Violations []string        `json:"violations"`
}

//go:generate go run github.com/golang/mock/mockgen -package=processor -self_package=processor -destination=./handler_mock.go . Handler
type Handler interface {
        Handle(Input) (Output, error)
}

type Processor struct {
        stdin   *json.Decoder
        stdout  *json.Encoder
        handler Handler
}

func NewProcessor(stdin io.Reader, stdout io.Writer, handler Handler) *Processor <span class="cov8" title="1">{
        return &amp;Processor{
                stdin:   json.NewDecoder(stdin),
                stdout:  json.NewEncoder(stdout),
                handler: handler,
        }
}</span>

func (p *Processor) Process() error <span class="cov8" title="1">{

        for </span><span class="cov8" title="1">{
                var input Input
                if err := p.stdin.Decode(&amp;input); err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("error while reading the input transaction file: %w", err)
                }</span>

                <span class="cov8" title="1">operation, err := p.handler.Handle(input)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("error while handling the transaction operation: %w", err)
                }</span>

                <span class="cov8" title="1">if err := p.stdout.Encode(operation); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error while trying to write the output response :%w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package authorizer

import (
        "authorizer/entity"
        "authorizer/processor"
        "errors"
)

type AuthorizeHandler struct {
        Manager
}

const (
        typeAccount     = 1
        typeTransaction = 2
)

func NewAuthorizeHandler() *AuthorizeHandler <span class="cov8" title="1">{
        return &amp;AuthorizeHandler{NewOperationManager()}
}</span>

func (a *AuthorizeHandler) Handle(input processor.Input) (output processor.Output, err error) <span class="cov8" title="1">{

        operationType := getOperationType(input)
        var account *entity.Account

        switch operationType </span>{
        case typeAccount:<span class="cov8" title="1">
                account, err = a.CreateAccount(*input.Account)</span>
        case typeTransaction:<span class="cov8" title="1">
                account, err = a.ProcessTransaction(*input.Transaction)</span>
        case 0:<span class="cov8" title="1">
                return processor.Output{}, errors.New("invalid operation type")</span>
        }

        <span class="cov8" title="1">violations := []string{}
        if err != nil </span><span class="cov8" title="1">{
                violations = append(violations, err.Error())

        }</span>

        <span class="cov8" title="1">return processor.Output{Account: account, Violations: violations}, nil</span>
}

func getOperationType(operation processor.Input) int <span class="cov8" title="1">{
        isAccount := operation.Account != nil
        isTransaction := operation.Transaction != nil

        if isAccount == false &amp;&amp; isTransaction == false </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if isAccount </span><span class="cov8" title="1">{
                return typeAccount
        }</span>
        <span class="cov8" title="1">return typeTransaction</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package authorizer

import (
        "authorizer/entity"
        "authorizer/entity/violations"
        "authorizer/usecase/rules"
        "errors"
)

//go:generate go run github.com/golang/mock/mockgen -package=authorizer -self_package=authorizer -destination=./manager_mock.go . Manager
type Manager interface {
        CreateAccount(account entity.Account) (*entity.Account, error)
        ProcessTransaction(transaction entity.Transaction) (*entity.Account, error)
}

type OperationManager struct {
        initialAccount *entity.Account
        trx            []entity.Transaction
}

func NewOperationManager() *OperationManager <span class="cov8" title="1">{
        return &amp;OperationManager{
                trx: []entity.Transaction{},
        }
}</span>

func (m *OperationManager) CreateAccount(account entity.Account) (*entity.Account, error) <span class="cov8" title="1">{

        if m.initialAccount != nil </span><span class="cov8" title="1">{
                return m.initialAccount, violations.ErrAccountAlreadyInitialized
        }</span>
        <span class="cov8" title="1">m.initialAccount = &amp;account

        return m.initialAccount, nil</span>
}

func (m *OperationManager) ProcessTransaction(transaction entity.Transaction) (*entity.Account, error) <span class="cov8" title="1">{
        if m.initialAccount == nil </span><span class="cov8" title="1">{
                return nil, errors.New("account-not-initialized")
        }</span>

        <span class="cov8" title="1">if !m.initialAccount.ActiveCard </span><span class="cov8" title="1">{
                return m.initialAccount, violations.ErrCardNotActive
        }</span>

        <span class="cov8" title="1">if !m.validateLimit(transaction) </span><span class="cov8" title="1">{
                return m.initialAccount, violations.ErrInsufficientLiit
        }</span>

        <span class="cov8" title="1">rules := rules.NewRules()

        err := rules.Authorize(&amp;transaction, m.trx)
        if err != nil </span><span class="cov8" title="1">{
                return m.initialAccount, err
        }</span>
        <span class="cov8" title="1">m.trx = append(m.trx, transaction)

        m.initialAccount.AvaliableLimit -= transaction.Amount
        return m.initialAccount, nil</span>
}

func (m *OperationManager) validateLimit(transaction entity.Transaction) bool <span class="cov8" title="1">{
        account := m.initialAccount

        if account.AvaliableLimit &lt; transaction.Amount </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: authorizer/usecase/authorizer (interfaces: Manager)

// Package authorizer is a generated GoMock package.
package authorizer

import (
        entity "authorizer/entity"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockManager is a mock of Manager interface.
type MockManager struct {
        ctrl     *gomock.Controller
        recorder *MockManagerMockRecorder
}

// MockManagerMockRecorder is the mock recorder for MockManager.
type MockManagerMockRecorder struct {
        mock *MockManager
}

// NewMockManager creates a new mock instance.
func NewMockManager(ctrl *gomock.Controller) *MockManager <span class="cov8" title="1">{
        mock := &amp;MockManager{ctrl: ctrl}
        mock.recorder = &amp;MockManagerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockManager) EXPECT() *MockManagerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateAccount mocks base method.
func (m *MockManager) CreateAccount(arg0 entity.Account) (*entity.Account, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateAccount", arg0)
        ret0, _ := ret[0].(*entity.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateAccount indicates an expected call of CreateAccount.
func (mr *MockManagerMockRecorder) CreateAccount(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccount", reflect.TypeOf((*MockManager)(nil).CreateAccount), arg0)
}</span>

// ProcessTransaction mocks base method.
func (m *MockManager) ProcessTransaction(arg0 entity.Transaction) (*entity.Account, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ProcessTransaction", arg0)
        ret0, _ := ret[0].(*entity.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ProcessTransaction indicates an expected call of ProcessTransaction.
func (mr *MockManagerMockRecorder) ProcessTransaction(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessTransaction", reflect.TypeOf((*MockManager)(nil).ProcessTransaction), arg0)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package rules

import (
        "authorizer/entity"
        "authorizer/entity/violations"
        "strings"
        "time"
)

type DoubleTransactionRule struct {
}

const (
        timeLimit = 2 * time.Minute
)

func NewDoubleTransactionRule() *DoubleTransactionRule <span class="cov8" title="1">{
        return &amp;DoubleTransactionRule{}
}</span>

func (d *DoubleTransactionRule) Authorize(trx []entity.Transaction, transaction *entity.Transaction) error <span class="cov8" title="1">{
        for _, o := range trx </span><span class="cov8" title="1">{
                if strings.Compare(o.Merchant, transaction.Merchant) == 0 </span><span class="cov8" title="1">{
                        duration := transaction.Time.Sub(o.Time)
                        if duration &lt; timeLimit </span><span class="cov8" title="1">{
                                return violations.ErrDoubleTransaction
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rules

import (
        "authorizer/entity"
        "authorizer/entity/violations"
)

type HighFrequencySmallIntervalRule struct {
}

func NewHighFrequencySmallIntervalRule() *HighFrequencySmallIntervalRule <span class="cov8" title="1">{
        return &amp;HighFrequencySmallIntervalRule{}
}</span>

func (d *HighFrequencySmallIntervalRule) Authorize(trx []entity.Transaction, transaction *entity.Transaction) error <span class="cov8" title="1">{

        sizeList := len(trx)

        if len(trx) &gt;= 3 </span><span class="cov8" title="1">{
                timeDiff := transaction.Time.Sub(trx[sizeList-3].Time)

                if timeDiff &lt; timeLimit </span><span class="cov8" title="1">{
                        return violations.ErrHighFrequencySmallInterval
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package rules

import (
        "authorizer/entity"
)

type Rules struct {
        rules *List
}

func (r *Rules) Authorize(transaction *entity.Transaction, trx []entity.Transaction) error <span class="cov8" title="1">{
        err := r.rules.DoubleTransactionRule.Authorize(trx, transaction)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = r.rules.HighFrequencySmallIntervalRule.Authorize(trx, transaction)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func NewRules() *Rules <span class="cov8" title="1">{
        return &amp;Rules{
                rules: NewRulesList(),
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package rules

type List struct {
        *DoubleTransactionRule
        *HighFrequencySmallIntervalRule
}

func NewRulesList() *List <span class="cov8" title="1">{
        return &amp;List{
                NewDoubleTransactionRule(),
                NewHighFrequencySmallIntervalRule(),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
